# 分支预测器

<style>
.center
{
    width: auto ;
    display: table;
    margin-left: auto;
    margin-right: auto;
}
</style>

[TOC]

---

## 1 前言

影响现代处理器性能的两大关键因素是cache与分支预测。该文主要介绍分支预测器与简单介绍目前使用的分支预测器设计方案。





## 2 介绍

指令的吞吐率决定了处理器性能的上限。**分支预测器目的是根据预测结果来实现不间断的指令流**，从而提高指令吞吐率，使处理器的CPI再度接近理想情况的1。

而针对分支指令的预测，需要预测2件事：

* 分支指令的跳转方向
* 分支指令的跳转目标地址



## 3 基本方法

对于分支指令来说，它的方向只有2个：跳转(Taken)与不跳(Not taken)，因此可以使用1与0来表示跳与不跳2个信息。对于大多数分支指令来说，其分支的跳转方向是有迹可循的，因此可以在硬件层面上打造一个通过训练来预测跳转方向的部件。而对于它的跳转目标来说，则可以从之前的每一次跳转之中进行记录与学习，从而训练来达到目标的预测跳转。本章以方向预测与目标预测两方面来进行方法说明。

### 3.1 方向预测

#### 3.1.1 基于两位饱和计数器的分支预测

该方法并不会马上使用分支指令上一次的结果，而是根据一条分支指令前面执行的结果来预测本次的方向。该方法使用一个2Bits的状态机（拥有4个状态）来表示，各个状态分别如下:

<div class="center">

|        状态        |                说明                | 编码 |
| :----------------: | :--------------------------------: | :--: |
|   Strongly Taken   |   计数器饱和，本次会被预测为跳转   | 2b11 |
|    Weakly Taken    |  计数器不饱和，本次会被预测为跳转  | 2b10 |
|  Weakly Not Taken  | 计数器不饱和，本次会被预测为不跳转 | 2b01 |
| Strongly Not Taken |  计数器饱和，本次会被预测为不跳转  | 2b00 |

</div>

<p align="center"><font face="微软雅黑" size=2.>表1 2Bits饱和计数器状态机各个状态含义以及计数器编码</font></p>

状态机的这些状态会根据每次的预测的结果<u>（预测正确与否）</u>来进行该计数器状态机的更新。规则如下：

* 当预测正确，会朝着预测的方向+1/-1，而当达到计数器饱和状态的时候，预测正确不会改变计数器状态；
* 当预测错误，那么会朝着预测相反的方向+1/-1

因此，该状态机的状态转移可以如下所示：

<div class="center">

![2bits](./2bit.png "2bits")

</div>

<p align="center"><font face="微软雅黑" size=2.>图1 2bits计数器状态转移图示</font></p>

预测器处于饱和状态时，只有2次预测失败才会改变预测的结果，当分支指令的方向总是朝着一个方向进行时，状态机就会处于饱和状态，此时预测的准确率会比较高。该方法是众多预测方法中所使用比较多的一种。



#### 3.1.2 分支形式历史表(Pattern History Table,PHT)

该表为PHT，其中，该表的每一个表项中都存储着一个2Bits饱和计数器的状态，可以使用分支指令的PC进行寻址，寻到的2Bits饱和计数器状态即为预测的分支方向(T/NT)。如果是对于一个 $32$位的$PC$来说，那么如果考虑每一位，那么总共需要一个$2^{30}*2 bits$的存储器或者寄存器堆空间来存储这些计数器的值（指令是字对齐，那么最低2位可以不纳入考虑）。但是，在现实中，不可能去使用如此大的存储空间来进行分支预测，而且并不是所有的指令都是分支指令，于是，可以采用$PC$的一部分来进行索引PHT，可以如下图所示：

<div class="center">

![pht](./pht.png "pht")

</div>

<p align="center"><font face="微软雅黑" size=2.>图2 PHT，使用PC一部分值来索引PHT</font></p>

#### 3.1.3 分支历史寄存器

使用一个寄存器来记录一条分支指令在过去的历史状态，当这个历史状态很有规律的时候，就可以为分支预测提供一个可以利用的工具，这样的寄存器被成为分支历史寄存器(Branch History Register,BHR)。一个位宽为$n$的分支历史寄存器可以记录过去$n$次分支指令的结果，当某条分支预测正确的时候，分支历史寄存器向左移动1位，并且在末位写1，当某条分支预测错误的时候，分支历史寄存器向左移动1位，并且在末位写0，如下所示：

~~~c
if(right){
    bhr = bhr << 1 | 'd1 ;
}else(miss){
    bhr = bhr << 1 | 'd0 ; 
}
~~~

如此，就可以使用BHR与PC来寻址PHT，来对分支指令进行一个更准确的预测。而在不同的设计中，BHR也有不同的设计

##### 3.1.3.1 全局分支历史寄存器

全局分支历史寄存器(Global Branch History Register)，顾名思义，负责全部分支指令的历史记录，因此只有1项，如下：

![ghr](./ghr.png "ghr")

<p align="center"><font face="微软雅黑" size=2.>图3 GHR,负责全部分支指令的历史记录</font></p>

这样，无论什么分支指令出预测结果，都使用该项进行结果的更新，而寻址PHT，则可以根据PC与GHR的值来进行操作之后，再去寻找PHT。

##### 3.1.3.2 局部分支历史寄存器

局部分支历史寄存器(Local Branch History Register,LHR)，对于每一条分支指令来说，都有一个独立的分支历史寄存器，也就是说是有$n$个BHR来对于$n$个分支指令进行查询与记录。假设说PC为$32$位，如果要遍历到每一个位，那么与PHT一样，需要$x^{32}$的储存空间($x$为每个BHR的位宽)，这是不现实的，因此，通常使用Hash处理之后的PC寻址LHR,再用寻到的LHR的值与一部分PC值拼接，再去寻找PHT，得到预测方向。

### 3.2 目标预测

分支指令的跳转目标地址可以分为2种，即直接跳转与间接跳转。对于直接跳转的分支指令，它的偏移值是以立即数的形式体现在指令之中，所以它的目标地址也是固定。只要记录下此分支指令的目标地址就可以了。而对于间接跳转的分支指令，由于它的目标地址来自于通用寄存器，经常发生变化，因此对于此类型的分支指令来说不容易预测，但是一般程序中，使用间接跳转来体现`call/return`指令，而这2种则是有规律可循的，可以对齐进行分支预测。

#### 3.2.1 直接跳转类型的分支预测

##### 3.2.1.1 BTB

对于此类跳转指令，由于分支预测是基于PC来进行的，于是我们可以使用一个Cache来进行这些预测目标的存储。由于不是每一个PC都对应着一个分支指令，因此可以使多个PC值共用这个Cache的存储空间，来储存目标地址，这个Cache被称为**BTB(Branch Target Buffer)**。

因为其本质上为一个Cache，所以可以使用常规Cache设计的结构来进行BTB的设计。使用PC的一部分来寻址BTB（此处该部分称为Index），其余部分作为Tag来进行寻找表项的匹配比较，来避免同一个Index寻找匹配到多个不同的目标地址。

BTB的运作与重填方案可以参照常规Cache来进行设计。当预测结果出来之后，更新BTB，若缺少匹配项，可以将预测地址置为下一个PC值或去其余预测目标储存部件中寻找。

#### 3.2.2 间接跳转类型的分支预测

##### 3.2.1.2 RAS

RAS(Return Address Stack)返回地址栈，按顺序存放着返回地址。

在一般的程序之中，通常，`call`指令用来调用子程序，使PC指向子程序的入口，开始取指执行子程序。而在子程序执行完毕之后，通常会使用`return`指令来返回到主程序调用`call`之后的指令，继续往下执行。

而对于`call`来说，每一个PC对应着不同的子程序入口地址，也就是`call`所使用的目标地址都是固定的，因此可以使用**BTB**来进行`call`的目标预测。

对于`call/return`指令的分支，可以使用一个栈来保存地址。当执行`call`指令的时候，将当前`call`指令的下一条指令的PC值存入该栈中，等进入子程序，执行完子程序之后，遇到`return`指令，就可以直接使用该栈之前保存的地址进行快速地返回主程序，往下执行。

以下面的代码段为例：程序会打印并且计算$5+(7-8)$的值，那么从程序来看，先`call printf`，之后就会去`call add`，之后再去`call sub`,之后，就会从`sub,add,printf`依次`return`。

~~~c
int add(int x , int y);
int sub(int x , int y);

void enter(void){
    printf("%d\n",add(5,sub(7,8)));
    return 0;
}
~~~

那么会有RAS:

<div class="center">

![ras](./ras.png "ras")

</div>

<p align="center"><font face="微软雅黑" size=2.>图4 RAS,执行了printf,add,sub三条指令之后存的值</font></p>

<div class ="center">
对`call`与`return`进行分支预测时，如下图所示：

![rasbp](./rasbpu.png "rasbp")

</div>

<p align="center"><font face="微软雅黑" size=2.>图5 对call与return进行分支预测</font></p>

## 4 分支预测器设计实例

在[第三节](#3 基本方法)中，简单说明了动态的分支预测器的预测的基本方法与设计方法。在此小节中，将简要介绍目前在具体设计中，用到的分支预测器的设计以及设计方法。

### 4.1 Gshare预测方法

本小节内容取自于[李志锐翻译的内容](https://zhuanlan.zhihu.com/p/450540990)与教材所记录<sup><a href="#ref1">[1]</a></sup>的内容整理而成。

在使用传统全局历史分支预测方法时，为了更好做出预测，通常是通过扩展历史表的长度来实现，这样可以获得更多的PHT寻址地址位数，**但是PHT的寻址位数每增加一位也会导致PHT的大小增大一倍**，因此会需要非常大的表来存储信息，这就是传统的方法上存在的问题。

为了解决这个问题，可以将全局分支历史寄存器与分支指令的地址中取出一部分，进行异或操作，然后附加分支指令地址中相对比特数较少的尾部，作为PHT的索引地址。图示如下：

<div class="center">

![gshare](./gshare.png "gshare")

</div>

<p align="center"><font face="微软雅黑" size=2.>图6 Gshare的工作方式</font></p>

当指令地址的中部相同时，指令地址下部对应的指令共用几个PHT表项，这样可以兼顾PHT的大小，改良了传统方法中PHT利用效率太差的问题。

这种方法使用了全局历史记录，但由于多个分支指令共用一个PHT，因此被叫做Gshare方法。该方法在各种benchmark(*一种用于测试分支效率的测试程序*)中都取得了不错的预测命中率。

### 4.2 混合预测/竞争型分支预测

在大多情况下，Gshare可以保证良好的预测命中率，但事实上不可能对于任何一种程序都是最优解，有些程序会更适合局部的分支预测方案。

因此，在现代处理器中，也有一些采用了混合预测/竞争型的预测方法。其实际是：

**采用了两个或者两个以上的预测机制实现的不同的分支预测器，之后，再根据一个额外的得分表，来选择预测率更高（或者是更合适）的分支预测方案的预测器进行预测的结果，来作为本次分支指令的预测结果。**

例如，一个采用了局部分支预测器与Gshare分支预测器的混合预测/竞争型分支预测器的行为图示：

![comp bpu](./mix.png "comp")

<p align="center"><font face="微软雅黑" size=2.>图7 局部分支预测器与Gshare预测器组成的混合预测器工作方式图示</font></p>

其中，该得分表类似于PHT，其中的表项可以类似于2bits饱和计数器的工作方式，可以使用指令地址一部分或者通过处理之后来进行访问。

* 当预测结果一致时，不更新
* 当一边预测正确时，朝着该预测器的方向前进
* 当一边预测错误时，朝着该预测器相反的方向前进

同样，以上面的混合预测器为例，那么该得分表的计数器编码可以设置为如下：

| 状态           | 说明           | 编码 |
| :--------------: | :--------------: | :----: |
| 使用Gshare     | 使用Gshare     | 0b11 |
| 使用Ghsare     | 使用Gshare     | 0b10 |
| 使用局部预测器 | 使用局部预测器 | 0b01 |
| 使用局部预测器 | 使用局部预测器 | 0b00 |

<p align="center"><font face="微软雅黑" size=2.>表2 得分表与各个状态编码</font></p>

如此，使用混合预测器来对分支指令进行预测，可以提高预测精度。

### 4.3 TAGE

TAGE,基于部分标记几何历史长度分支预测方法<sup><a href="#ref2">[2]</a></sup>。该方法现也被广泛采用，使用于现代处理器之中。主要是使用利用了几种不同长度的历史表来捕捉非常遥远的分支结果与最近分支历史的相关性，之后计算最终的预测结果。

#### 4.3.1 PPM-like

结构如下为图示<sup><a href="#ref3">[3]</a></sup>。

![ppm-like](./ppmlike.png "ppmlike")

<p align="center"><font face="微软雅黑" size=2.>图9 PPM-like预测器</font></p>

其中，最左侧称为`bank0`，其是一个bi-mode predictor([双峰预测器](https://zhuanlan.zhihu.com/p/579747343]))，共计有$2^{12}=4K$项，由PC的低12位进行索引，每一项包含一个$3bits$的饱和计数器与$1bit$的$m,(meta-predictor,元预测器)$。在其右侧的4个`bank1~3`为**最近全局历史长度表**，由PC与一些全局历史长度$h$进行索引。由上图可得，每个`bank`的全局历史长度$h$分别为$10,20,40,80$，分别对应了不同距离的分支历史。在这里，每个bank中的每一个表项都由一个$3bits$的饱和计数器$ctr$，$8bits$的tag，与$1bits$的$u,(useful entry)$组成。

##### 4.3.1.1 预测获取

在获取预测的时候，5个`bank`同时运作，找到各个bank之中对应的表项，对于`bank1~3`，取对应项的tag与当前$branch pc$与$h$中hash出来的$8bits$数据进行对比，相同即命中，命中则认为当前bank预测taken。最终的预测结果采用命中的`bank`之中最高历史长度的预测结果。如果`bank1~3`都未命中，则采用`bank0`的预测结果。

##### 4.3.1.2 更新策略

在更新时，当指令执行完毕，会获得到预测来自`bank x`，以及预测结果是否正确。

**更新$3bits$饱和计数器**：只更新$bank x$中命中的那一项的$ctr$，预测正确+1；预测错误则-1，处于最大值或最小值（即饱和；边界），则不变。

**分配新项**：

* 若预测正确则不需要分配表项；
* 若预测错误，取$bank (x+1)~bank 3$的对应项的$u$，替换其中的$u=0$的项，若无，则从中任意选取一项进行替换。之后，$tag$填充该$bank$的hash出来的$8bits-tag$；$u$填充0；$ctr$填充$100$或者$011$，选择规则如下：
  * 读取`bank0`对应项的$m$，若为1，看`bank x`预测结果是`taken`或是`not taken`，`taken`填充$100$,反之填充$011$。若为0，看`bank0`预测结果是`taken`或是`not taken`，`taken`填充$100$,反之填充$011$。
* 更新$u,m$：只更新`bank x`的对应项的$u,m$。预测结果正确则都置$1$，错误则全置$0$。

#### 4.3.2 TAGE预测方法

如下，为TAGE预测方法运行图示。

![tage](./tage.png "tage")

<p align="center"><font face="微软雅黑" size=2.>图9 TAGE预测方法结构图示</font></p>

TAGE分支预测器直接源于[PPM-like](#4.3.1 PPM-like)，基于tag的分支预测器。由元基准预测器$base\ predictor\ T0$，与 一序列$(partially\ Tagged\ predictor\ components\ ，\ T_i)$组成。$T_i$所采用索引历史长度与[PPM-like](#4.3.1 PPM-like)一致，是不同的，成几何长度关系，记长度为$L$，则每一个$T_i$的历史长度可以表示为：$L(i)=\alpha_{i-1}L(1)$。

其中$T_0$为一个基础的分支预测器，可以为简单PC索引的$2bits$饱和计数器。

$T_i,0 \le i < M$则是由$3bits$的$signed\ ctr$、$tag$与$2bits\ u,(unsigned useful ctr)$组成。

##### 4.3.2.1 预测获取

预测方法与[PPM-like](#4.3.1 PPM-like)相似，若`tag`命中，则取历史长度最长的$T_x$的预测结果，若未命中，则取$T_0$的预测结果。

##### 4.3.2.2 更新策略

**provider component**： tag命中，则取其中历史长度最长的component;若无，**则为base predictor**。

**alternate component**： 次级tag命中的component；若无，**则为base predictor**。

**更新$u$**：如果$provider component \neq altpred$，更新$provider component$中对应项的$u$。此外，**周期性**地重置所有$u$，先重置高位，再重置低位。在此图中，周期为$256k\ branch$。

在预测正确的时候，更新$provider component$的$ctr$。

在预测错误时，需要：

* 更新$provider component$的$ctr$；
* 分配新项(至多分配1项)：
  * 若$provider component$为$T_i$，则读取$T_{i+1}\sim T_{M}$ 的对应项的$u$，若有$u=0$，替换其中最低历史长度的表项，若无，则这些$u=u-1$。
  * 填充的$ctr$为弱跳状态，$u=0$。



## 总结与后记

本文是从分支预测器的作用开始做介绍，从基础的设计模块到目前常用的设计方案较为清晰地介绍了分支预测器在现代处理器中的作用，并且结合文献或互联网资料做了整理，整合而成。本文目前仅作为学习记录，记录整理学习分支预测器的设计方案。本文内容或多或少存在记录不详细的情况，会根据学习进度与内容来进行修订与编写。

## 参考与引用

\[1\]. <span name="ref1">姚永斌.超标量处理器设计.北京：清华大学出版社.2014.</span>

[2]. <span name="ref2">Seznec, André & Michaud, Pierre. (2006). <I>A case for (partially) TAgged GEometric history length branch prediction.</I> Journal of Instruction-level Parallelism - JILP. 8. </span>

[3]. <span name="ref3">P. Michaud, A ppm-like, tag-based predictor. *Journal of Instruction Level Parallelism(http://www.jilp.org/vo17)*, April 2005</span>

